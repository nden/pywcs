/* This file is autogenerated by setup.py.  To edit its contents
   edit doc/docstrings.py
*/
const char doc_Wcs[] = "Wcs objects can convert between pixel and world coordinates, based on\nthe WCS settings in a FITS file.\n\nTo create Wcs objects, one would normally use L{parse_image_header}.\n\n@raises MemoryError: Memory allocation failed.";

const char doc_cd[] = "@type 2x2 array.\n\nFor historical compatibility, two alternate specifications of the\nlinear transformation matrix are supported, those associated with the\nC{CDi_ja} and C{CROTAia} keywords.  Although these may not formally\nco-exist with C{PCi_ja}, the approach here is simply to ignore them if\ngiven in conjunction with C{PCi_ja}.\n\nL{has_pci_ja}, L{has_cdi_ja} and L{has_crotaia} can be used to\ndetermine which of these alternatives are present in the header.\n\nC{CDi_ja} and C{CROTAia} keywords, if found, are to be stored in the\nL{cd} and L{crota} arrays which are dimensioned similarly to L{pc} and\nL{cdelt}.\n\nThese alternate specifications of the linear transformation matrix\nare translated immediately to C{PCi_ja} by L{set} and are nowhere\nvisible to the lower-level routines.  In particular, L{set} resets\nL{cdelt} to unity if C{CDi_ja} is present (and no C{PCi_ja}).  If no C{CROTAia}\nis associated with the latitude axis, L{set} reverts to a unity\nC{PCi_ja} matrix.";

const char doc_cdelt[] = "@type array[naxis]\n\nCoordinate increments (C{CDELTia}) for each coord axis.";

const char doc_celfix[] = "celfix() -> int\n\nTranslates AIPS-convention celestial projection types, C{-NCP}\nand C{-GLS}.\n\n@return: C{0} for success; C{-1} if no change required.";

const char doc_copy[] = "copy()\n\nCreates a deep copy of the Wcs object.\"";

const char doc_crota[] = "@type array[2][2]\n\nC{CROTAia} keyvalues for each coord axis.\n\nC{CROTAia} is an alternate\nspecification of the linear transformation matrix, maintained for\nhistorical compatibility.\n\n@see: L{cd} for more information.";

const char doc_crpix[] = "@type array[naxis]\n\nCoordinate reference pixels (C{CRPIXja}) for each pixel axis.";

const char doc_crval[] = "@type array[naxis]\n\nCoordinate reference values (C{CRVALia}) for each coordinate axis.";

const char doc_ctype[] = "@type list of strings\n\nList of C{CTYPEia} keyvalues.\n\nThe L{ctype} keyword values must be in upper case and there must\nbe zero or one pair of matched celestial axis types, and zero or one\nspectral axis.";

const char doc_cubeface[] = "@type int\n\nIndex into the C{pixcrd} (pixel coordinate) array for the C{CUBEFACE}\naxis.  This is used for quadcube projections where the cube faces are\nstored on a separate axis.\n\nThe quadcube projections (C{TSC}, C{CSC}, C{QSC}) may be\nrepresented in FITS in either of two ways:\n\n    - The six faces may be laid out in one plane and numbered as\n      follows::\n\n\n                                       0\n\n                              4  3  2  1  4  3  2\n\n                                       5\n\n      Faces 2, 3 and 4 may appear on one side or the other (or both).\n      The world-to-pixel routines map faces 2, 3 and 4 to the left but\n      the pixel-to-world routines accept them on either side.\n\n    - The C{\"COBE\"} convention in which the six faces are stored in a\n      three-dimensional structure using a C{\"CUBEFACE\"} axis indexed from\n      0 to 5 as above.\n\nThese routines support both methods; L{set} determines which is being\nused by the presence or absence of a C{CUBEFACE} axis in L{ctype}.\nL{p2s} and L{s2p} translate the C{CUBEFACE} axis representation to the\nsingle plane representation understood by the lower-level projection\nroutines.";

const char doc_cunit[] = "@type: list of strings\n\nList of C{CUNITia} keyvalues which define the units of measurement of the\nC{CRVALia}, C{CDELTia} and C{CDi_ja} keywords.\n\nAs C{CUNITia} is an optional header keyword, L{cunit} may be left\nblank but otherwise is expected to contain a standard units\nspecification as defined by WCS Paper I.  Utility function\nC{wcsutrn()}, (not currently wrapped for Python) is available to translate\ncommonly used non-standard units specifications but this must be\ndone as a separate step before invoking L{set}.\n\nFor celestial axes, if L{cunit} is not blank, L{set} uses C{wcsunits}\nto parse it and scale L{cdelt}, L{crval}, and L{cd} to degrees.  It\nthen resets L{cunit} to \"deg\".\n\nFor spectral axes, if L{cunit} is not blank, L{set} uses C{wcsunits}\nto parse it and scale L{cdelt}, L{crval}, and L{cd} to SI units.  It\nthen resets L{cunit} accordingly.\n\nL{set} ignores L{cunit} for other coordinate types; L{cunit} may be\nused to label coordinate values.";

const char doc_cylfix[] = "Fixes WCS keyvalues for malformed cylindrical projections.\n\n@return: C{0} for success; C{-1} if no change required.\n@rtype: int";

const char doc_datfix[] = "datfix() -> int\n\nTranslates the old C{DATE-OBS} date format to year-2000 standard form\nC{(yyyy-mm-ddThh:mm:ss)} and derives C{MJD-OBS} from it if not already set.\nAlternatively, if C{mjdobs} is set and C{dateobs} isn\'t, then L{datfix}\nderives C{dateobs} from it.  If both are set but disagree by more than\nhalf a day then C{ValueError} is raised.\n\n@return: C{0} for success; C{-1} if no change required.";

const char doc_fix[] = "fix(translate_units=\'\', naxis=0) -> dict\n\nApplies all of the corrections handled separately by L{datfix},\nL{unitfix}, L{celfix}, L{spcfix} and L{cylfix}.\n\n@param translate_units: Do potentially unsafe translations of non-standard\n    unit strings.\n\n    Although C{\"S\"} is commonly used to represent seconds,\n    its translation to C{\"s\"} is potentially unsafe since\n    the standard recognizes C{\"S\"} formally as Siemens,\n    however rarely that may be used.  The same applies\n    to C{\"H\"} for hours (Henry), and C{\"D\"} for days (Debye).\n\n    This string controls what to do in such cases, and is case-insensitive.\n\n        - If the string contains C{\"s\"}, translate C{\"S\"} to C{\"s\"}.\n        - If the string contains C{\"h\"}, translate C{\"H\"} to C{\"h\"}.\n        - If the string contains C{\"d\"}, translate C{\"D\"} to C{\"d\"}.\n\n    Thus C{\'\'} doesn\'t do any unsafe translations, whereas C{\'shd\'}\n    does all of them.\n@type translate_units: string\n\n@param naxis: Image axis lengths.  If this array pointer is set to zero,\n    then L{cylfix} will not be invoked.\n@type naxis: array[naxis] of int\n\n@return: A dictionary containing the following keys, each referring to a\n    status string for each of the sub-fix functions that were called:\n    L{datfix}, L{unitfix}, L{celfix}, L{spcfix}, L{cylfix}.";

const char doc_has_cdi_ja[] = "has_cdi_ja() -> bool\n\nReturns C{True} if C{CDi_ja} is present.  C{CDi_ja} is an alternate\nspecification of the linear transformation matrix, maintained for\nhistorical compatibility.\n\n@see: L{cd} for more information.\n\nMatrix elements in the IRAF convention are equivalent to the product\nC{CDi_ja = CDELTia * PCi_ja}, but the defaults differ from that of the\nC{PCi_ja} matrix.  If one or more C{CDi_ja} keywords are present then all\nunspecified C{CDi_ja} default to zero.  If no C{CDi_ja} (or C{CROTAia})\nkeywords are present, then the header is assumed to be in C{PCi_ja} form\nwhether or not any C{PCi_ja} keywords are present since this results in\nan interpretation of C{CDELTia} consistent with the original FITS\nspecification.\n\nWhile C{CDi_ja} may not formally co-exist with C{PCi_ja}, it may\nco-exist with C{CDELTia} and C{CROTAia} which are to be ignored.\"";

const char doc_has_crotaia[] = "has_crotaia() -> bool\n\nReturns True if C{CROTAia} is present.  C{CROTAia} is an alternate\nspecification of the linear transformation matrix, maintained for\nhistorical compatibility.\n\n@see: L{cd} for more information.\n\nIn the AIPS convention, C{CROTAia} may only be associated with the\nlatitude axis of a celestial axis pair.  It specifies a rotation in\nthe image plane that is applied AFTER the C{CDELTia}; any other C{CROTAia}\nkeywords are ignored.\n\nC{CROTAia} may not formally co-exist with C{PCi_ja}.  C{CROTAia} and\nC{CDELTia} may formally co-exist with C{CDi_ja} but if so are to be\nignored.\n\"";

const char doc_has_pci_ja[] = "has_pci_ja() -> bool\n\nReturns True if C{PCi_ja} is present.  C{PCi_ja} is the recommended way\nto specify the linear transformation matrix.\n\n@see: L{cd} for more information.";

const char doc_lat[] = "@type: int\n\nThe index into the world coordinate array containing latitude values.";

const char doc_latpole[] = "@type: float\n\nThe native latitude of the celestial pole, C{LATPOLEa} (deg).";

const char doc_lng[] = "@type: int\n\nThe index into the world coordinate array containing longitude values.";

const char doc_lonpole[] = "@type: float\n\nThe native longitude of the celestial pole, C{LONPOLEa} (deg).";

const char doc_mix[] = "mix(mixpix, mixcel, vspan, vstep, viter, world, pixcrd) -> dict\n\nGiven either the celestial longitude or latitude plus an element\nof the pixel coordinate, solves for the remaining elements by iterating on\nthe unknown celestial coordinate element using L{s2p}.\n\n@param mixpix: Which element on the pixel coordinate is given.\n@type mixpix: int\n\n@param mixcel: Which element of the celestial coordinate is given:\n        1. Celestial longitude is given in C{world[self.L{lng}]}, latitude\n           returned in C{world[self.L{lat}]}.\n        2. Celestial latitude is given in world[self.lat], longitude\n           returned in C{world[self.L{lng}]}\n@type mixcel: int\n\n@param vspan: Solution interval for the celestial coordinate, in degrees.\n    The ordering of the two limits is irrelevant.  Longitude ranges may be\n    specified with any convenient normalization, for example\n    C{(-120,+120)} is the same as C{(240,480)}, except that the solution\n    will be returned with the same normalization, i.e. lie within the\n    interval specified.\n@type vspan: 2-tuple of floats\n\" // Make this a generic sequence\n\n@param vstep: Step size for solution search, in degrees.  If C{0}, a\n    sensible, although perhaps non-optimal default will be used.\n@type vstep: float\n\n@param viter: If a solution is not found then the step size will be halved\n    and the search recommenced.  C{viter} controls how many times the step\n    size is halved.  The allowed range is 5 - 10.\n@type viter: int\n\n@param world: World coordinate elements.  C{world[self.lng]} and C{world[self.lat]}\n    are the celestial longitude and latitude, in degrees.  Which is\n    given and which returned depends on the value of mixcel.  All\n    other elements are given.  The results will be written to this\n    array in-place.\n@type world: array[naxis]\n\n@param pixcrd: Pixel coordinate.  The element indicated by mixpix is given\n    and the remaining elements will be written in-place.\n@type pixcrd: array[naxis]\n\n@return: A dictionary with the following keys:\n    - C{phi} I{(type=array[naxis])}\n    - C{theta} I{(type=array[naxis])}\n        - Longitude and latitude in the native coordinate system of the\n          projection, in degrees.\n    - C{imgcrd} I{type=array[naxis])}\n        - Image coordinate elements.  C{imgcrd[self.lng]} and\n          C{imgcrd[self.lat]} are the projected I{x}- and\n          I{y}-coordinates, in \"degrees\".\n\n@raise MemoryError: Memory allocation failed.\n@raise SingularMatrixError: Linear transformation matrix is singular.\n@raise InconsistentAxisTypesError: Inconsistent or unrecognized coordinate\n    axis types.\n@raise ValueError: Invalid parameter value.\n@raise InvalidTransformError: Invalid coordinate transformation parameters.\n@raise InvalidTransformError: Ill-conditioned coordinate\ntransformation parameters.\n@raise InvalidCoordinateError: Invalid world coordinate.\n@raise NoSolutionError: No solution found in the specified interval.";

const char doc_naxis[] = "@type: int\n\nThe number of axes (pixel and coordinate), given by the C{NAXIS} or\nC{WCSAXESa} keyvalues.";

const char doc_p2s[] = "p2s(pixcrd) -> dict\n\nConverts pixel to world coordinates.\n\n@param pixcrd: Array of pixel coordinates.\n@type pixcrd: numpy array[ncoord][nelem]\n\n@return: A dictionary with the following keys:\n        - C{imgcrd} I{(type=array[ncoord][nelem])}\n            - Array of intermediate world coordinates.  For celestial\n              axes, C{imgcrd[][self.lng]} and C{imgcrd[][self.lat]} are the\n              projected I{x}-, and I{y}-coordinates, in \"degrees\".  For\n              spectral axes, C{imgcrd[][self.spec]} is the intermediate\n              spectral coordinate, in SI units.\n        - C{phi} I{(type=array[ncoord])}\n        - C{theta} I{(type=array[ncoord])}\n            - Longitude and latitude in the native coordinate system\n              of the projection, in degrees.\n        - C{world} I{(type=array[ncoord][nelem])}\n            - Array of world coordinates.  For celestial axes,\n              C{world[][self.lng]} and C{world[][self.lat]} are the celestial\n              longitude and latitude, in degrees.  For spectral axes,\n              C{imgcrd[][self.spec]} is the intermediate spectral\n              coordinate, in SI units.\n        - C{stat} I{(type=array[ncoord])}\n            - Status return value for each coordinate. C{0} for success, C{1}\n              for invalid pixel coordinate.\n\n@raises MemoryError: Memory allocation failed.\n@raises SingularMatrixError: Linear transformation matrix is singular.\n@raises InconsistentAxisTypesError: Inconsistent or unrecognized\n    coordinate axis types.\n@raises ValueError: Invalid parameter value.\n@raises InvalidTransformError: Invalid coordinate transformation\n    parameters.\n@raises InvalidTransformError: Ill-conditioned coordinate transformation\n    parameters.";

const char doc_parse_image_header[] = "parse_image_header(header, relax=0) -> list of C{Wcs} objects\n\nParses a FITS image header, either that of a primary HDU or of an image\nextension.  All WCS keywords defined in Papers I, II, and III are\nrecognized, and also those used by the AIPS convention and certain\nother keywords that existed in early drafts of the WCS papers.\n\nGiven a string containing a FITS image header, C{parse_image_header()}\nidentifies and reads all WCS keywords for the primary coordinate\nrepresentation and up to 26 alternate representations.  It returns\nthis information as a list of C{Wcs} objects.\n\nC{parse_image_header()} fills in information associated with\ncoordinate lookup tables.\n\nC{wcspih} determines the number of coordinate axes independently for\neach alternate coordinate representation (denoted by the C{\"a\"} value in\nkeywords like C{CTYPEia}) from the higher of\n    - C{NAXIS}\n    - C{WCSAXES}\n    - The highest axis number in any parameterized WCS keyword.  The\n      keyvalue, as well as the keyword, must be syntactically valid\n      otherwise it will not be considered.\n\nIf none of these keyword types is present, i.e. if the header only\ncontains auxiliary WCS keywords for a particular coordinate\nrepresentation, then no coordinate description is constructed for it.\n\nC{wcspih} enforces correct FITS \"keyword = value\" syntax with regard\nto C{\"= \"} occurring in columns 9 and 10.  However, it does\nrecognize free-format character (NOST 100-2.0, Sect. 5.2.1), integer\n(Sect. 5.2.3), and floating-point values (Sect. 5.2.4) for all\nkeywords.\n\nWhere CROTAn, CDi_ja, and PCi_ja occur together in one header, wcspih()\nand wcsbth() treat them as described in the prologue to wcs.h.\n\n\n\n@param header: String containing the (entire) FITS image header from which to\n    identify and construct the coordinate representations.\n@type header: string\n@param relax: Degree of permissiveness:\n    - C{False}: Recognize only FITS keywords defined by the\n      published WCS standard.\n    - C{True}: Admit all recognized informal extensions of the\n      WCS standard.\n@type relax: bool\n\n@return: A list of C{Wcs} objects, containing up to 27 coordinate\n    representations.";

const char doc_pc[] = "@type: array[2][2]\n\nThe C{PCi_ja} (pixel coordinate) transformation matrix.  The order is::\n\n  [[PC1_1, PC1_2],\n   [PC2_1, PC2_2]]";

const char doc_print_contents[] = "print_contents()\n\nPrint the contents of the Wcs object to stdout.  Probably only useful\nfor debugging purposes, and may be removed in the future.";

const char doc_ps[] = "@type: list of tuples\n\nC{PSi_ma} keywords for each I{i} and I{m}.  Returned as a list of\ntuples of the form (I{i}, I{m}, I{value}):\n\n    - I{i}: axis number, as in C{PSi_ma}, (i.e. 1-relative)\n    - I{m}: parameter number, as in C{PSi_ma}, (i.e. 0-relative)\n    - I{value}: parameter value (as a string)";

const char doc_pv[] = "@type: list of tuples\n\nC{PVi_ma} keywords for each I{i} and I{m}.  Returned as a list of\ntuples of the form (I{i}, I{m}, I{value}):\n\n    - I{i}: axis number, as in C{PVi_ma}, (i.e. 1-relative)\n    - I{m}: parameter number, as in C{PVi_ma}, (i.e. 0-relative)\n    - I{value}: parameter value (as a string)";

const char doc_restfrq[] = "@type: float\n\nRest frequency (Hz) from C{RESTFRQa}.";

const char doc_restwav[] = "@type: float\n\nRest wavelength (m) from C{RESTWAVa}.";

const char doc_s2p[] = "s2p(world) -> dict\n\nTransforms world coordinates to pixel coordinates.\n\n\n@param world: Array of world coordinates.\n@type world: array[ncoord][nelem]\n\n@return: A dictionary with the following keys:\n        - C{phi} I{(type=array[ncoord])}\n        - C{theta} I{(type=array[ncoord])}\n            - Longitude and latitude in the native coordinate system\n              of the projection, in degrees.\n        - C{imgcrd} I{(type=array[ncoord][nelem])}\n            - Array of intermediate world coordinates.  For celestial\n              axes, C{imgcrd[][self.lng]} and C{imgcrd[][self.lat]} are the\n              projected I{x}-, and I{y}-coordinates, in \"degrees\".  For\n              quadcube projections with a C{CUBEFACE} axis, the face\n              number is also returned in C{imgcrd[][self.cubeface]}.  For\n              spectral axes, C{imgcrd[][self.spec]} is the intermediate\n              spectral coordinate, in SI units.\n        - C{pixcrd} I{(type=array[ncoord][nelem])}\n            - Array of pixel coordinates.\n        - C{stat} I{(type=array[ncoord])}\n            - Status return value for each coordinate. C{0} for success, C{1}\n              for invalid pixel coordinate.\n\n@raises MemoryError: Memory allocation failed.\n@raises SingularMatrixError: Linear transformation matrix is singular.\n@raises InconsistentAxisTypesError: Inconsistent or unrecognized\n    coordinate axis types.\n@raises ValueError: Invalid parameter value.\n@raises InvalidTransformError: Invalid coordinate transformation\n    parameters.\n@raises InvalidTransformError: Ill-conditioned coordinate\n    transformation parameters.";

const char doc_set[] = "set()\n\nSets up a Wcs object for use according to information supplied within\nit.\n\nC{set} recognizes the C{NCP} projection and converts it to the equivalent\nC{SIN} projection and it also recognizes C{GLS} as a synonym for C{SFL}.  It\ndoes alias translation for the AIPS spectral types (C{FREQ-LSR}, C{FELO-HEL},\netc.) but without changing the input header keywords.\n\nNote that this routine need not be called directly; it will be invoked by\nL{p2s} and L{s2p} if necessary.\n\nC{set} strips off trailing blanks in all string members.\n\n@raises MemoryError: Memory allocation failed.\n@raises SingularMatrixError: Linear transformation matrix is singular.\n@raises InconsistentAxisTypesError: Inconsistent or unrecognized coordinate axis\n    types.\n@raises ValueError: Invalid parameter value.\n@raises InvalidTransformError: Invalid coordinate transformation parameters.\n@raises InvalidTransformError: Ill-conditioned coordinate transformation\n    parameters.";

const char doc_spcfix[] = "spcfix() -> int\n\nTranslates AIPS-convention spectral coordinate types.\n{C{FREQ},C{VELO},C{FELO}}-{C{OBS},C{HEL},C{LSR}} (e.g. C{FREQ-LSR},\nC{VELO-OBS}, C{FELO-HEL})\n\n@return: C{0} for success; C{-1} if no change required.";

const char doc_spec[] = "@type: int\n\nThe index containing the spectral axis values.";

const char doc_sptr[] = "sptr(ctype, i=-1)\n\nTranslates the spectral axis in a Wcs object.  For example, a C{FREQ} axis\nmay be translated into C{ZOPT-F2W} and vice versa.\n\n@param ctype: Required spectral C{CTYPEia}.  Wildcarding may be used, i.e.\n    if the final three characters are specified as C{\"???\"}, or if just the\n    eighth character is specified as C{\"?\"}, the correct algorithm code will\n    be substituted and returned.\n@type ctype: string\n\n@param i: Index of the spectral axis (0-rel).  If C{i < 0} (or not provided),\n    it will be set to the first spectral axis identified from the C{CTYPE}\n    keyvalues in the FITS header.\n\n@raises MemoryError: Memory allocation failed.\n@raises SingularMatrixError: Linear transformation matrix is singular.\n@raises InconsistentAxisTypesError: Inconsistent or unrecognized\n    coordinate axis types.\n@raises ValueError: Invalid parameter value.\n@raises InvalidTransformError: Invalid coordinate transformation\n    parameters.\n@raises InvalidTransformError: Ill-conditioned coordinate\n    transformation parameters.\n@raises InvalidSubimageSpecificationError: Invalid subimage\n    specification (no spectral axis).";

const char doc_unitfix[] = "unitfix(translate_units=\'\') -> int\n\nTranslates non-standard C{CUNITia} keyvalues.\nFor example, C{DEG} -> C{deg}, also stripping off unnecessary whitespace.\n\n@param translate_units: Do potentially unsafe translations of non-standard\n    unit strings.\n\n    Although C{\"S\"} is commonly used to represent seconds,\n    its translation to C{\"s\"} is potentially unsafe since\n    the standard recognizes C{\"S\"} formally as Siemens,\n    however rarely that may be used.  The same applies\n    to C{\"H\"} for hours (Henry), and C{\"D\"} for days (Debye).\n\n    This string controls what to do in such cases, and is case-insensitive.\n\n        - If the string contains C{\"s\"}, translate C{\"S\"} to C{\"s\"}.\n        - If the string contains C{\"h\"}, translate C{\"H\"} to C{\"h\"}.\n        - If the string contains C{\"d\"}, translate C{\"D\"} to C{\"d\"}.\n\n    Thus C{\'\'} doesn\'t do any unsafe translations, whereas C{\'shd\'}\n    does all of them.\n\n@return: C{0} for success; C{-1} if no change required.";

